//Nathan Park
//4/16/22
//Data Type, Functions, Algorithms


/**********************************
DataTypes

//Could be eliminated and use string, but the enum will allow for easier iterations
enum ShipClassification{ CARRIER, BATTLESHIP, DESTROYER, SUBMARINE, TORPEDOBOAT};

struct Coordinate //represents a single cell of the board
{
	int x; //horizontal
	int y; //vertical
}

struct CoordinateList
{
    Coordinate individualCoordinate;
    int numberOfCoordinates;
}

struct Ship //all necessary aspects of a single ship peice
{
	ShipClassification shipType;
	bool isSunk; (true is sunk, false is still afloat)
	bool isHorizontal; (true is horizontal orientation false if vertical)
	int shipSize; (number of spaces on board the ship takes up)
	char shipArray[]; (holds the status of each ship segment
};

struct BoardElement
{
	char actualValue; (true value of the location ship present or not)
	char displayedValue; (what's displayed to the user)
	bool shipPresent; (true if a ship is there)
	char* shipCoordinate; (points to the array of ship segments char shipArray[k] from struct Ship)
}

END DATA STRUCTURES
**********************************/


/**********************************
    FUNCTIONS

//Takes an array holding each pointer of type Ship variable and defines the location of its ship variable in dynamic memory
//Preconditions: allShipsArray is declared with number of elements equal to NUMBEROFSHIPS
//Postconditions: each element of allShips holds a pointer to a new Ship variable
void PopulateAllShipsArray( Ship* allShipsArray[] //InOut)


//Takes an array of Ship pointers and defines the properties of each ship
//Preconditions: allShipsArray is populated with pointers to each new Ship
//Postconditions: each Ship has shipSize defined, shipType defined, isSunk = false, isHorizontal = true or false,
//                and shipArray populated with shipSize number of '#' chars
void AssignShipProperties( Ship allShipsArray[] //InOut)

//Populates the gameboard with initial properties for each BoardElement to start in known state
//Preconditions: gameBoard declared, MAXBOARDSIZE declared
//Postconditions: gameboard of Size MAXBOARDSIZE by MAXBOARDSIZE created with all actual and displaced values
//                as ocean characters and shipPresent as false and shipCoordinate = NULLPTR
void GenerateBlankBoard( boardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE] //InOut)

//Assigns ship locations to gameBoard
//Preconditions: gameBoard generated by GenerateBlankBoard, allShips is populated and defined, NUMBEROFSHIPS is defined
//Postconditions: each allShipsArray shipArray element has a unique pointer in gameBoard pointing to it. stored in char* shipCoordinate of gameBoard
//                each shipArray associate pointer is sequentially horizontal or vertical and does not overlap with any other shipCoordinate
void PlaceShips( BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE] //InOut, Ships* allShipsArray[NUMBEROFSHIPS] //in, int NUMBEROFSHIPS //in)

//Returns a Record of Coordinates representing valid locations to place a ship of a given size and orientation
//Preconditions: ShipSize, isHorizontal, gameBoard are defined, validLocations is declared
//Postconditions: An array of Coordinates is returned such that the given ship will not overlap with another ship
bool ValidLocation(int ShipSize //in, bool isHorizontal// in, BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE] //in, CoordinateList validLocations //in)

//Returns a single coordinate representing the starting placement point for a ship
//Preconditions: validLocations defined
//Postconditions: returns a randomly selected single coordinate value
Coordinate ChooseLocation(CoordinateList validLocations //in)

// Gets a guess and updates gameBoard as feedback
// Preconditions: gameBoard is defined, CoordinateList is defined
// Postconditions: gameBoard is updated, guessHistory is updated with most recent guess and number of guesses
void GameTurn(BoardElement gameBoard //InOut, CoordinateList guessHistory //InOut)

// Validates a guess and updates guessHistory
// Preconditions: currentGuess, guessHistory, MAXBOARDSIZE are defined
// Postconditions: returns true is guess is valid and false if otherwise
bool ValidGuess( Coordinate currentGuess //In, CoordinateList guessHistory //In, int MAXBOARDSIZE //In)

// Takes the currentGuess and upDates gameBoard displayedValue and Ship coordinate if hit
// Preconditions: currentGuess is validated, gameBoard is defined
// Postconditions: gameBoard is updated and re output to player
void UpDateBoard( Coordinate currentGuess //In, BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE] //InOut)

// Checks if a ship is sunk and outputs to user if sunk
// Preconditions: allShipsArray is defined
// Postconditions: if all chars in a Ship shipArray are H, the updates isSunk to true
void CheckShipStatus(Ship* allShipsArray[NUMBEROFSHIPS] //InOut)

//Returns true if all ships are sunk
//Preconditions: allShipsArray is defined
//Postconditions: returns true if all members of allShipsArray isSunk are true
bool CheckWinConditions(Ship* allShipsArray[NUMBEROFSHIPS] //In)

//Ends game and returns frees memory
//Preconditions: allShipsArray is defined
//Postconditions: destroys are Ships in dynamic memory and returns all pointers in gameBoard to NULLPTR
void EndGame(BoardElement gameBoard //InOut, Ship* allShipsArray //InOut)

**********************************/

/*************************************
GLOBALS

//control size of arrays
const int MAXBOARDSIZE = 10;
const int NUMBEROFSHIPS = 5;

//disambiguate characters
const char OCEAN = '~';
const char SHIP = '#';
const char HIT = 'H';


END GLOBALS
*************************************/


/*************************************
MAIN

//Declare the gameBoard array of size

BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE]

Ship* allShipsArray[NUMBEROFFSHIPS - 1]

//Initialize the guess history variable

CoordinateList guessHistory;
guessHistory.numberOfCoordinates = 0;

//Declare Ship variables in Dynamic memory with pointers held in allShipsArray
Call PopulateAllShipsArray( allShipsArray )

// Define the properties of each ship
Call AssignShipsProperties( allShipsArray )

// Define the initial sate of the gameBoard
Call GenerateBlankBoard( gameBoard )

// Place the ships on the gameBoard
Call PlaceShips(gameBoard, allShipsArray, NUMBEROFSHIPS)

// Iterate through guess until all ships sunk and guesses don't exceed number of board elements
while( not all ships sunk OR guessHistory.numberOfCoordinate <= MAXBOARDSIZE * MAXBOARDSIZE)
    Call GameTurn(BoardElement gameBoard, CoordinateList guessHistory)



*************************************/

/**************************************
FUNCTION HEIRARCHY

    FUNCTIONS


void PopulateAllShipsArray( Ship* allShipsArray[] //InOut)

void AssignShipProperties( Ship allShipsArray[] //InOut)

void GenerateBlankBoard( boardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE] //InOut)

void PlaceShips( BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE], Ships* allShipsArray[NUMBEROFSHIPS], int NUMBEROFSHIPS)

    ValidLocation(int ShipSize, bool isHorizontal, BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE], CoordinateList validLocations)

    ChooseLocation(CoordinateList validLocations)

void GameTurn(BoardElement gameBoard, CoordinateList guessHistory)

    bool ValidGuess( Coordinate currentGuess, CoordinateList guessHistory, int MAXBOARDSIZE)

    void UpDateBoard( Coordinate currentGuess, BoardElement gameBoard[MAXBOARDSIZE][MAXBOARDSIZE])

    void CheckShipStatus(Ship* allShipsArray[NUMBEROFSHIPS])

    bool CheckWinConditions(Ship* allShipsArray[NUMBEROFSHIPS])

    void EndGame(BoardElement gameBoard, Ship* allShipsArray)



**************************************/
